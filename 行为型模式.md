行为型模式总  
[策略模式](#clm)   
[观察者模式](#gcz)   
[责任链模式](#zrl)   
[模板方法](#mbf)   
[状态模式](#ztm)   
<A name="clm"> 策略模式 </A>  

意图：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。

主要解决：在有多种算法相似的情况下，使用 if...else 所带来的复杂和难以维护。

何时使用：一个系统有许多许多类，而区分它们的只是他们直接的行为。

如何解决：将这些算法封装成一个一个的类，任意地替换。

关键代码：实现同一个接口。

应用实例： 1、诸葛亮的锦囊妙计，每一个锦囊就是一个策略。 2、旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略。 3、JAVA AWT 中的 LayoutManager。

优点： 1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好。

缺点： 1、策略类会增多。 2、所有策略类都需要对外暴露。

使用场景： 1、如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 2、一个系统需要动态地在几种算法中选择一种。 3、如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。

注意事项：如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。

![uml图](https://github.com/shenxixi250/photo/blob/master/shejimoshi_photo/11_21_001_1.png) 

```

Strategy.java
public interface Strategy {
   public int doOperation(int num1, int num2);
}

```

```

OperationAdd.java
public class OperationAdd implements Strategy{
   @Override
   public int doOperation(int num1, int num2) {
         return num1 + num2;
      }
}


OperationSubstract.java
public class OperationSubstract implements Strategy{
   @Override
   public int doOperation(int num1, int num2) {
         return num1 - num2;
      }
}
OperationMultiply.java
public class OperationMultiply implements Strategy{
   @Override
   public int doOperation(int num1, int num2) {
         return num1 * num2;
      }
}

```
```

Context.java
public class Context {
   private Strategy strategy;
 
   public Context(Strategy strategy){
         this.strategy = strategy;
      }
 
   public int executeStrategy(int num1, int num2){
         return strategy.doOperation(num1, num2);
      }
}

```

```

context 来查看当它改变策略 Strategy 时的行为变化。
StrategyPatternDemo.java
public class StrategyPatternDemo {
	public static void main(String[] args) {
		Context context = new Context(new OperationAdd());    
		System.out.println("10 + 5 = " + context.executeStrategy(10, 5));

		context = new Context(new OperationSubstract());      
		System.out.println("10 - 5 = " + context.executeStrategy(10, 5));

		context = new Context(new OperationMultiply());    
		System.out.println("10 * 5 = " + context.executeStrategy(10, 5));
	}
}
```
注意和桥梁模式比较 他们要我说的话，它们非常相似，桥梁模式在左侧加了一层抽象而已。桥梁模式的耦合更低，结构更复杂一些。  
这个是一个博主说的

但是我觉的 一个是行为模式驱动的  一个是结构类的模式   他们针对的过程是不一样的   策略模式强调的是行为 而桥接模式强调的是构建的问题  



<A name="gcz"> 观察者模式 </A>  

 意图：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。

 主要解决：一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。

 何时使用：一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。

 如何解决：使用面向对象技术，可以将这种依赖关系弱化。

 关键代码：在抽象类里有一个 ArrayList 存放观察者们。

 应用实例： 1、拍卖的时候，拍卖师观察最高标价，然后通知给其他竞价者竞价。 2、西游记里面悟空请求菩萨降服红孩儿，菩萨洒了一地水招来一个老乌龟，这个乌龟就是观察者，他观察菩萨洒水这个动作。

 优点： 1、观察者和被观察者是抽象耦合的。 2、建立一套触发机制。

 缺点： 1、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 2、如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 3、观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。 

 使用场景：

 一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。
 一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。
 一个对象必须通知其他对象，而并不知道这些对象是谁。 需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。

注意事项 
1 java中已经有了对观察这模式的支持类
2 避免循环引用 
3 如果顺序执行,一个观察者会导致系统卡壳 ,一般采用异步模式

首先我们要有一个保存观察者的容器 然后在容器中输入我们大家要统一的状态值
```
import java.util.ArrayList;
import java.util.List;

public class Subject {

	private List<Observer> observers
		= new ArrayList<Observer>();
	private int state;

	public int getState() {
		return state;
	}

	public void setState(int state) {
		this.state = state;
		notifyAllObservers();
	}

	public void attach(Observer observer){
		observers.add(observer);
	}

	public void notifyAllObservers(){
		for (Observer observer : observers) {
			observer.update();
		}
	}
}
```
然后我们要写一个观察者的抽象类  然后和之前的容器进行组合 
```
public abstract class Observer {
    protected Subject subject;
    public abstract void update();
}
```
实现需要观察的类
```
public class HexaObserver extends Observer{

	public HexaObserver(Subject subject){
		this.subject = subject;
		this.subject.attach(this);
	} 
	@Override
		public void update() {
			System.out.println( "Hex String: " + Integer.toHexString( subject.getState() ).toUpperCase() );
		}
}

```
public class BinaryObserver extends Observer{

    public BinaryObserver(Subject subject){
		this.subject = subject;
		this.subject.attach(this);
	}

	@Override
		public void update() {
			System.out.println( "Binary String: " + Integer.toBinaryString( subject.getState() ) );
		}
}
```
public class OctalObserver extends Observer{

	public OctalObserver(Subject subject){
		this.subject = subject;
		this.subject.attach(this);
	}

	@Override
		public void update() {
			System.out.println( "Octal String: " + Integer.toOctalString( subject.getState() ) );
		}
}
```

最后在执行我们每次要换的命令
```
public class ObserverPatternDemo {
	public static void main(String[] args) {
		Subject subject = new Subject();

		new HexaObserver(subject);
		new OctalObserver(subject);
		new BinaryObserver(subject);

		System.out.println("First state change: 15");
		subject.setState(15);
		System.out.println("Second state change: 10");
		subject.setState(10);
	}
}
```



<A name="zrl"> 责任链模式 </A>  

意图：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。

主要解决：职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。

何时使用：在处理消息的时候以过滤很多道。

如何解决：拦截的类都实现统一接口。

关键代码：Handler 里面聚合它自己，在 HandlerRequest 里判断是否合适，如果没达到条件则向下传递，向谁传递之前 set 进去。

应用实例：2、JS 中的事件冒泡。 3、JAVA WEB 中 Apache Tomcat 对 Encoding 的处理，Struts2 的拦截器，jsp servlet 的 Filter。

优点： 1、降低耦合度。它将请求的发送者和接收者解耦。 2、简化了对象。使得对象不需要知道链的结构。 3、增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。 4、增加新的请求处理类很方便。

缺点： 1、不能保证请求一定被接收。 2、系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。 3、可能不容易观察运行时的特征，有碍于除错。

使用场景： 1、有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定。 2、在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。 3、可动态指定一组对象处理请求。

![](https://github.com/shenxixi250/photo/blob/master/shejimoshi_photo/11_21_002_3.png) 

对原理类图的说明-即(职责链模式的角色及职责)
	1. Handler : 抽象的处理者, 定义了一个处理请求的接口, 同时含义另外 Handler
	2. ConcreteHandlerA , B 是具体的处理者, 处理它自己负责的请求, 可以访问它的后继者(即下一个处理者), 如果 可以处理当前请求,则处理,否则就将该请求交个 后继者去处理,从而形成一个职责链
	3. Request , 含义很多属性,表示一个请求

1) 应用实例要求
编写程序完成学校 OA 系统的采购审批项目:需求
采购员采购教学器材
如果金额 小于等于 5000, 由教学主任审批
如果金额 小于等于 10000, 由院长审批
如果金额 小于等于 30000, 由副校长审批
如果金额 超过 30000 以上,有校长审批
原始的实现要if else实现


![](https://github.com/shenxixi250/photo/blob/master/shejimoshi_photo/11_21_001_3.png) 
 

```
public abstract class Approver {
	Approver approver;
	//下一个处理者
	String name; // 名字
	public Approver(String name) {
		// TODO Auto-generated constructor stub
		this.name = name;
	}
	//下一个处理者
	public void setApprover(Approver approver) {
		this.approver = approver;
	}
	//处理审批请求的方法,得到一个请求, 处理是子类完成,因此该方法做成抽象
	public abstract void processRequest(PurchaseRequest purchaseRequest);


}
```
```
public class CollegeApprover extends  Approver{
	public CollegeApprover(String name) {
		// TODO Auto-generated constructor stub
		super(name);
	}
	@Override
		public void processRequest(PurchaseRequest purchaseRequest) {
			// TODO Auto-generated method stub
			if(purchaseRequest.getPrice() < 5000 && purchaseRequest.getPrice() <= 10000) {
				System.out.println(" 请求编号 id= " + purchaseRequest.getId() + " 被 " + this.name + " 处理");
			}else {
				approver.processRequest(purchaseRequest);
			}
		}

}

```

```
public class DepartmentApprover extends Approver {
	public DepartmentApprover(String name) {
		// TODO Auto-generated constructor stub
		super(name);
	}
	@Override
		public void processRequest(PurchaseRequest purchaseRequest) {
			// TODO Auto-generated method stub
			if(purchaseRequest.getPrice() <= 5000) {
				System.out.println(" 请求编号 id= " + purchaseRequest.getId() + " 被 " + this.name + " 处理");
			}else {
				approver.processRequest(purchaseRequest);
			}
		}
}
```

```

public class SchoolMasterApprover extends Approver {
	public SchoolMasterApprover(String name) {
		// TODO Auto-generated constructor stub
		super(name);
	}
	@Override
		public void processRequest(PurchaseRequest purchaseRequest) {
			// TODO Auto-generated method stub
			if(purchaseRequest.getPrice() > 30000) {
				System.out.println(" 请求编号 id= " + purchaseRequest.getId() + " 被 " + this.name + " 处理");
			}else {
				approver.processRequest(purchaseRequest);
			}
		}
}
```


```
public class ViceSchoolMasterApprover extends Approver {
	public ViceSchoolMasterApprover(String name) {
		// TODO Auto-generated constructor stub
		super(name);
	}
	@Override
		public void processRequest(PurchaseRequest purchaseRequest) {
			// TODO Auto-generated method stub
			if(purchaseRequest.getPrice() < 10000 && purchaseRequest.getPrice() <= 30000) {
				System.out.println(" 请求编号 id= " + purchaseRequest.getId() + " 被 " + this.name + " 处理");
			}else {
				approver.processRequest(purchaseRequest);
			}
		}

}
```

```
package com.test.zherenlian2;

public class PurchaseRequest {
	private int type = 0; //请求类型
	private float price = 0.0f; //请求金额
	private int id = 0;
	//构造器
	public PurchaseRequest(int type, float price, int id) {
		this.type = type;
		this.price = price;
		this.id = id;
	}
	public int getType() {
		return type;
	}
	public float getPrice() {
		return price;
	}
	public int getId() {
		return id;
	}
}
```

<++>

```
public class Client {
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		//创建一个请求
		PurchaseRequest purchaseRequest = new PurchaseRequest(1, 31000, 1);
		//创建相关的审批人
		DepartmentApprover departmentApprover = new DepartmentApprover("张主任");
		CollegeApprover collegeApprover = new CollegeApprover("李院长");
		ViceSchoolMasterApprover viceSchoolMasterApprover = new ViceSchoolMasterApprover("王副校");
		SchoolMasterApprover schoolMasterApprover = new SchoolMasterApprover("佟校长");
		//需要将各个审批级别的下一个设置好 (处理人构成环形: )
		departmentApprover.setApprover(collegeApprover);
		collegeApprover.setApprover(viceSchoolMasterApprover);
		viceSchoolMasterApprover.setApprover(schoolMasterApprover);
		schoolMasterApprover.setApprover(departmentApprover);
		departmentApprover.processRequest(purchaseRequest);
		viceSchoolMasterApprover.processRequest(purchaseRequest);
	}
}

```

ok  debug了一下整个的程序流程就是
....

<A name="mbf"> 模板方法 </A>  

模板方法也太简单了吧  

就是定义一个抽象类 然后其他方法去继承 重写里面的抽象方法 而公共的费抽象方法不需要重写大家都可以使用 

意图：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。

主要解决：一些方法通用，却在每一个子类都重新写了这一方法。

何时使用：有一些通用的方法。

如何解决：将这些通用算法抽象出来。

关键代码：在抽象类实现，其他步骤在子类实现。

应用实例： 1、在造房子的时候，地基、走线、水管都一样，只有在建筑的后期才有加壁橱加栅栏等差异。 2、西游记里面菩萨定好的 81 难，这就是一个顶层的逻辑骨架。 3、spring 中对 Hibernate 的支持，将一些已经定好的方法封装起来，比如开启事务、获取 Session、关闭 Session 等，程序员不重复写那些已经规范好的代码，直接丢一个实体就可以保存。

优点： 1、封装不变部分，扩展可变部分。 2、提取公共代码，便于维护。 3、行为由父类控制，子类实现。

缺点：每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。

使用场景： 1、有多个子类共有的方法，且逻辑相同。 2、重要的、复杂的方法，可以考虑作为模板方法。

注意事项：为防止恶意操作，一般模板方法都加上 final 关键词。
例子也很简单

```

public abstract class Game {
   abstract void initialize();
   abstract void startPlay();
   abstract void endPlay();
 
   //模板
   public final void play(){
    
         //初始化游戏
         initialize();
    
         //开始游戏
         startPlay();
    
         //结束游戏
         endPlay();
      }
}

```

```

Cricket.java
public class Cricket extends Game {

	@Override
		void endPlay() {
			System.out.println("Cricket Game Finished!");
		}

	@Override
		void initialize() {
			System.out.println("Cricket Game Initialized! Start playing.");
		}

	@Override
		void startPlay() {
			System.out.println("Cricket Game Started. Enjoy the game!");
		}
}
Football.java
public class Football extends Game {

	@Override
		void endPlay() {
			System.out.println("Football Game Finished!");
		}

	@Override
		void initialize() {
			System.out.println("Football Game Initialized! Start playing.");
		}

	@Override
		void startPlay() {
			System.out.println("Football Game Started. Enjoy the game!");
		}
}
```

```
TemplatePatternDemo.java
public class TemplatePatternDemo {
   public static void main(String[] args) {
    
         Game game = new Cricket();
         game.play();
         System.out.println();
         game = new Football();
         game.play();      
      } }


```



<A NAME="ztm">状态模式</A> 
介绍

意图：允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。

主要解决：对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为。

何时使用：代码中包含大量与对象状态有关的条件语句。

如何解决：将各种具体的状态类抽象出来。

关键代码：通常命令模式的接口中只有一个方法。而状态模式的接口中有一个或者多个方法。而且，状态模式的实现类的方法，一般返回值，或者是改变实例变量的值。也就是说，状态模式一般和对象的状态有关。实现类的方法有不同的功能，覆盖接口中的方法。状态模式和命令模式一样，也可以用于消除 if...else 等条件选择语句。

应用实例： 1、打篮球的时候运动员可以有正常状态、不正常状态和超常状态。 2、曾侯乙编钟中，'钟是抽象接口'`钟A'等是具体状态，'曾侯乙编钟'是具体环境（Context）。

优点： 1、封装了转换规则。 2、枚举可能的状态，在枚举状态之前需要确定状态种类。 3、将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。 4、允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。 5、可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。

缺点： 1、状态模式的使用必然会增加系统类和对象的个数。 2、状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。 3、状态模式对"开闭原则"的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态，而且修改某个状态类的行为也需修改对应类的源代码。

使用场景： 1、行为随状态改变而改变的场景。 2、条件、分支语句的代替者。

注意事项：在行为受状态约束的时候使用状态模式，而且状态不超过 5 个。

![](https://github.com/shenxixi250/photo/blob/master/shejimoshi_photo/11_22_001_0.png) 
 
```

public interface State {
   public void doAction(Context context);
}



StartState.java
public class StartState implements State { 
	public void doAction(Context context) {
		System.out.println("Player is in start state");
		context.setState(this); 
	} 
	public String toString(){
		return "Start State";
	}
}




StopState.java
public class StopState implements State { 
	public void doAction(Context context) {
		System.out.println("Player is in stop state");
		context.setState(this); 
	} 
	public String toString(){
		return "Stop State";
	}
}
```


```

Context.java
public class Context {
   private State state;
 
   public Context(){
         state = null;
      }
 
   public void setState(State state){
         this.state = state;     
      }
 
   public State getState(){
         return state;
      }
}

```

```

StatePatternDemo.java
public class StatePatternDemo {
   public static void main(String[] args) {
         Context context = new Context();
    
         StartState startState = new StartState();
         startState.doAction(context);
    
         System.out.println(context.getState().toString());
    
         StopState stopState = new StopState();
         stopState.doAction(context);
    
         System.out.println(context.getState().toString());
      }
}

```

使用 Context 来查看当状态 State 改变时的行为变化。

```
Player is in start state
Start State
Player is in stop state
Stop State
```

[策略模式和状态模式的异同](https://www.runoob.com/w3cnote/state-vs-strategy.html)


