行为型模式总  
[策略模式](#clm)   
[观察者模式](#gcz)   
[责任链模式](#zrl)   
[模板方法](#mbf)   
  
<A name="clm"> 策略模式 </A>  

意图：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。

主要解决：在有多种算法相似的情况下，使用 if...else 所带来的复杂和难以维护。

何时使用：一个系统有许多许多类，而区分它们的只是他们直接的行为。

如何解决：将这些算法封装成一个一个的类，任意地替换。

关键代码：实现同一个接口。

应用实例： 1、诸葛亮的锦囊妙计，每一个锦囊就是一个策略。 2、旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略。 3、JAVA AWT 中的 LayoutManager。

优点： 1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好。

缺点： 1、策略类会增多。 2、所有策略类都需要对外暴露。

使用场景： 1、如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 2、一个系统需要动态地在几种算法中选择一种。 3、如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。

注意事项：如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。

![uml图](https://github.com/shenxixi250/photo/blob/master/shejimoshi_photo/11_21_001_1.png) 

```

Strategy.java
public interface Strategy {
   public int doOperation(int num1, int num2);
}

```

```

OperationAdd.java
public class OperationAdd implements Strategy{
   @Override
   public int doOperation(int num1, int num2) {
         return num1 + num2;
      }
}


OperationSubstract.java
public class OperationSubstract implements Strategy{
   @Override
   public int doOperation(int num1, int num2) {
         return num1 - num2;
      }
}
OperationMultiply.java
public class OperationMultiply implements Strategy{
   @Override
   public int doOperation(int num1, int num2) {
         return num1 * num2;
      }
}

```
```

Context.java
public class Context {
   private Strategy strategy;
 
   public Context(Strategy strategy){
         this.strategy = strategy;
      }
 
   public int executeStrategy(int num1, int num2){
         return strategy.doOperation(num1, num2);
      }
}

```

```

context 来查看当它改变策略 Strategy 时的行为变化。
StrategyPatternDemo.java
public class StrategyPatternDemo {
	public static void main(String[] args) {
		Context context = new Context(new OperationAdd());    
		System.out.println("10 + 5 = " + context.executeStrategy(10, 5));

		context = new Context(new OperationSubstract());      
		System.out.println("10 - 5 = " + context.executeStrategy(10, 5));

		context = new Context(new OperationMultiply());    
		System.out.println("10 * 5 = " + context.executeStrategy(10, 5));
	}
}

注意和桥梁模式比较 他们要我说的话，它们非常相似，桥梁模式在左侧加了一层抽象而已。桥梁模式的耦合更低，结构更复杂一些。  
这个是一个博主说的

但是我觉的 一个是行为模式驱动的  一个是结构类的模式   他们针对的过程是不一样的   策略模式强调的是行为 而桥接模式强调的是构建的问题  



<A name="gcz"> 观察者模式 </A>  

 意图：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。

 主要解决：一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。

 何时使用：一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。

 如何解决：使用面向对象技术，可以将这种依赖关系弱化。

 关键代码：在抽象类里有一个 ArrayList 存放观察者们。

 应用实例： 1、拍卖的时候，拍卖师观察最高标价，然后通知给其他竞价者竞价。 2、西游记里面悟空请求菩萨降服红孩儿，菩萨洒了一地水招来一个老乌龟，这个乌龟就是观察者，他观察菩萨洒水这个动作。

 优点： 1、观察者和被观察者是抽象耦合的。 2、建立一套触发机制。

 缺点： 1、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 2、如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 3、观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。 

 使用场景：

 一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。
 一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。
 一个对象必须通知其他对象，而并不知道这些对象是谁。 需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。

注意事项 
1 java中已经有了对观察这模式的支持类
2 避免循环引用 
3 如果顺序执行,一个观察者会导致系统卡壳 ,一般采用异步模式

首先我们要有一个保存观察者的容器 然后在容器中输入我们大家要统一的状态值
```
import java.util.ArrayList;
import java.util.List;

public class Subject {

	private List<Observer> observers
		= new ArrayList<Observer>();
	private int state;

	public int getState() {
		return state;
	}

	public void setState(int state) {
		this.state = state;
		notifyAllObservers();
	}

	public void attach(Observer observer){
		observers.add(observer);
	}

	public void notifyAllObservers(){
		for (Observer observer : observers) {
			observer.update();
		}
	}
}
```
然后我们要写一个观察者的抽象类  然后和之前的容器进行组合 
```
public abstract class Observer {
    protected Subject subject;
    public abstract void update();
}
```
实现需要观察的类
```
public class HexaObserver extends Observer{

	public HexaObserver(Subject subject){
		this.subject = subject;
		this.subject.attach(this);
	} 
	@Override
		public void update() {
			System.out.println( "Hex String: " + Integer.toHexString( subject.getState() ).toUpperCase() );
		}
}

```
public class BinaryObserver extends Observer{

    public BinaryObserver(Subject subject){
		this.subject = subject;
		this.subject.attach(this);
	}

	@Override
		public void update() {
			System.out.println( "Binary String: " + Integer.toBinaryString( subject.getState() ) );
		}
}
```
```
public class OctalObserver extends Observer{

	public OctalObserver(Subject subject){
		this.subject = subject;
		this.subject.attach(this);
	}

	@Override
		public void update() {
			System.out.println( "Octal String: " + Integer.toOctalString( subject.getState() ) );
		}
```

最后在执行我们每次要换的命令
```
public class ObserverPatternDemo {
	public static void main(String[] args) {
		Subject subject = new Subject();

		new HexaObserver(subject);
		new OctalObserver(subject);
		new BinaryObserver(subject);

		System.out.println("First state change: 15");
		subject.setState(15);
		System.out.println("Second state change: 10");
		subject.setState(10);
	}
}
```



<A name="zrl"> 责任链模式 </A>  

意图：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。

主要解决：职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。

何时使用：在处理消息的时候以过滤很多道。

如何解决：拦截的类都实现统一接口。

关键代码：Handler 里面聚合它自己，在 HandlerRequest 里判断是否合适，如果没达到条件则向下传递，向谁传递之前 set 进去。

应用实例：2、JS 中的事件冒泡。 3、JAVA WEB 中 Apache Tomcat 对 Encoding 的处理，Struts2 的拦截器，jsp servlet 的 Filter。

优点： 1、降低耦合度。它将请求的发送者和接收者解耦。 2、简化了对象。使得对象不需要知道链的结构。 3、增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。 4、增加新的请求处理类很方便。

缺点： 1、不能保证请求一定被接收。 2、系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。 3、可能不容易观察运行时的特征，有碍于除错。

使用场景： 1、有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定。 2、在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。 3、可动态指定一组对象处理请求。

![](https://github.com/shenxixi250/photo/blob/master/shejimoshi_photo/11_21_002_3.png) 

对原理类图的说明-即(职责链模式的角色及职责)
	1) Handler : 抽象的处理者, 定义了一个处理请求的接口, 同时含义另外 Handler
	2) ConcreteHandlerA , B 是具体的处理者, 处理它自己负责的请求, 可以访问它的后继者(即下一个处理者), 如果 可以处理当前请求,则处理,否则就将该请求交个 后继者去处理,从而形成一个职责链
	3) Request , 含义很多属性,表示一个请求

1) 应用实例要求
编写程序完成学校 OA 系统的采购审批项目:需求
采购员采购教学器材
如果金额 小于等于 5000, 由教学主任审批
如果金额 小于等于 10000, 由院长审批
如果金额 小于等于 30000, 由副校长审批
如果金额 超过 30000 以上,有校长审批
原始的实现要if else实现


![](https://github.com/shenxixi250/photo/blob/master/shejimoshi_photo/11_21_001_3.png) 
 

```
public abstract class Approver {
	Approver approver;
	//下一个处理者
	String name; // 名字
	public Approver(String name) {
		// TODO Auto-generated constructor stub
		this.name = name;
	}
	//下一个处理者
	public void setApprover(Approver approver) {
		this.approver = approver;
	}
	//处理审批请求的方法,得到一个请求, 处理是子类完成,因此该方法做成抽象
	public abstract void processRequest(PurchaseRequest purchaseRequest);


}
```
```
public class CollegeApprover extends  Approver{
	public CollegeApprover(String name) {
		// TODO Auto-generated constructor stub
		super(name);
	}
	@Override
		public void processRequest(PurchaseRequest purchaseRequest) {
			// TODO Auto-generated method stub
			if(purchaseRequest.getPrice() < 5000 && purchaseRequest.getPrice() <= 10000) {
				System.out.println(" 请求编号 id= " + purchaseRequest.getId() + " 被 " + this.name + " 处理");
			}else {
				approver.processRequest(purchaseRequest);
			}
		}

}

```

```
public class DepartmentApprover extends Approver {
	public DepartmentApprover(String name) {
		// TODO Auto-generated constructor stub
		super(name);
	}
	@Override
		public void processRequest(PurchaseRequest purchaseRequest) {
			// TODO Auto-generated method stub
			if(purchaseRequest.getPrice() <= 5000) {
				System.out.println(" 请求编号 id= " + purchaseRequest.getId() + " 被 " + this.name + " 处理");
			}else {
				approver.processRequest(purchaseRequest);
			}
		}
}
```

```

public class SchoolMasterApprover extends Approver {
	public SchoolMasterApprover(String name) {
		// TODO Auto-generated constructor stub
		super(name);
	}
	@Override
		public void processRequest(PurchaseRequest purchaseRequest) {
			// TODO Auto-generated method stub
			if(purchaseRequest.getPrice() > 30000) {
				System.out.println(" 请求编号 id= " + purchaseRequest.getId() + " 被 " + this.name + " 处理");
			}else {
				approver.processRequest(purchaseRequest);
			}
		}
}
```


```
public class ViceSchoolMasterApprover extends Approver {
	public ViceSchoolMasterApprover(String name) {
		// TODO Auto-generated constructor stub
		super(name);
	}
	@Override
		public void processRequest(PurchaseRequest purchaseRequest) {
			// TODO Auto-generated method stub
			if(purchaseRequest.getPrice() < 10000 && purchaseRequest.getPrice() <= 30000) {
				System.out.println(" 请求编号 id= " + purchaseRequest.getId() + " 被 " + this.name + " 处理");
			}else {
				approver.processRequest(purchaseRequest);
			}
		}

}
```

```
package com.test.zherenlian2;

public class PurchaseRequest {
	private int type = 0; //请求类型
	private float price = 0.0f; //请求金额
	private int id = 0;
	//构造器
	public PurchaseRequest(int type, float price, int id) {
		this.type = type;
		this.price = price;
		this.id = id;
	}
	public int getType() {
		return type;
	}
	public float getPrice() {
		return price;
	}
	public int getId() {
		return id;
	}
}
```

<++>

```
public class Client {
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		//创建一个请求
		PurchaseRequest purchaseRequest = new PurchaseRequest(1, 31000, 1);
		//创建相关的审批人
		DepartmentApprover departmentApprover = new DepartmentApprover("张主任");
		CollegeApprover collegeApprover = new CollegeApprover("李院长");
		ViceSchoolMasterApprover viceSchoolMasterApprover = new ViceSchoolMasterApprover("王副校");
		SchoolMasterApprover schoolMasterApprover = new SchoolMasterApprover("佟校长");
		//需要将各个审批级别的下一个设置好 (处理人构成环形: )
		departmentApprover.setApprover(collegeApprover);
		collegeApprover.setApprover(viceSchoolMasterApprover);
		viceSchoolMasterApprover.setApprover(schoolMasterApprover);
		schoolMasterApprover.setApprover(departmentApprover);
		departmentApprover.processRequest(purchaseRequest);
		viceSchoolMasterApprover.processRequest(purchaseRequest);
	}
}

```

ok  debug了一下整个的程序流程就是
....

<A name="mbf"> 模板方法 </A>  

