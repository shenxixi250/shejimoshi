[单例模式](#dlm)  
[工厂模式](#cxg) 
 + 简单工厂
 + 方法工厂
 + 抽象工厂

[原型模式](#yxm)  
[建造者模式](#jzz) 

<A name="dlm"> 单例模式 </A>  

所谓类的单例设计模式,就是采取一定的方法保证在整个的软件系统中,对某个类只能存在一个对象实例,并且该类只提供一个取得其对象实例的方法(静态方法)。

比如说
在项目中有
比如 Hibernate 的 SessionFactory,它充当数据存储源的代理,并负责创建 Session 对象。SessionFactory 并不是轻量级的,一般情况下,一个项目通常只需要一个 SessionFactory 就够,这是就会使用到单例模式。
日常中 就是任务管理器


单例设计模式八种方式
单例模式有八种方式:
1. 饿汉式(静态常量)
2. 饿汉式(静态代码块)
3. 懒汉式(线程不安全)
4. 懒汉式(线程安全,同步方法)
5. 懒汉式(线程安全,同步代码块)
6. 双重检查
7. 静态内部类
8. 枚举

饿汉式的构造
步骤如下
1) 构造器私有化 (防止 new )
2) 类的内部创建对象
3) 向外暴露一个静态的公共方法。getInstance
4) 代码实现
```
/饿汉式(静态变量)
class Singleton {
//1. 构造器私有化, 外部能 new
private Singleton() {}
//2.本类内部创建对象实例
private final static Singleton instance = new Singleton();
//也可以使用静态代码块来进行实现
//private static Singleton instance;
// static {instance = new Singleton();}//就是这样 这种方式和上面的方式其实类似,只不过将类实例化的过程放在了静态代码块中,
//也是在类装载的时候,就执行静态代码块中的代码,初始化类的实例。优缺点和上面是一样的
//3. 提供一个公有的静态方法,返回实例对象
public static Singleton getInstance() {
return instance;
}
}
/*
 优缺点说明:
1) 优点:这种写法比较简单,就是在类装载的时候就完成实例化。避免了线程同步问题。
2) 缺点:在类装载的时候就完成实例化,没有达到 Lazy Loading 的效果。如果从始至终从未使用过这个实例,则会造成内存的浪费
3) 这种方式基于 classloder 机制避免了多线程的同步问题,不过,instance 在类装载时就实例化,在单例模式中大多数都是调用 getInstance 方法
,但是导致类装载的原因有很多种,因此不能确定有其他的方式(或者其他的静态方法)导致类装载,这时候初始化 instance 就没有达到 lazy loading 的效果
4) 结论:这种单例模式可用,可能造成内存浪费
*/
```

赖汉式 方法 这里就介绍一种最安全的
```
// 懒汉式(线程安全,同步方法)
public class SingletonTest06 {
public static void main(String[] args) {
System.out.println("双重检查");
Singleton instance = Singleton.getInstance();
Singleton instance2 = Singleton.getInstance();
System.out.println(instance == instance2); // true
System.out.println("instance.hashCode=" + instance.hashCode());
System.out.println("instance2.hashCode=" + instance2.hashCode());
}
}
class Singleton {
private static volatile Singleton instance;
private Singleton() {}
//提供一个静态的公有方法,加入双重检查代码,解决线程安全问题, 同时解决懒加载问题
//同时保证了效率, 推荐使用
public static synchronized Singleton getInstance() {
if(instance == null) {
synchronized (Singleton.class) {
if(instance == null) {
instance = new Singleton();
}
}
}
return instance;
}
}
 优缺点说明:
1) Double-Check 概念是多线程开发中常使用到的,如代码中所示,我们进行了两次 if (singleton == null)检查,这样就可以保证线程安全了。
2) 这样,实例化代码只用执行一次,后面再次访问时,判断 if (singleton == null),直接 return 实例化对象,也避免的反复进行方法同步.
3) 线程安全;延迟加载;效率较高
4) 结论:在实际开发中,推荐使用这种单例设计模式
```
使用枚举,可以实现单例
```
//使用枚举,可以实现单例, 推荐
enum Singleton {
	INSTANCE; //属性
public void sayOK() {
System.out.println("ok~");
}
}
优缺点说明
1) 这借助 JDK1.5 中添加的枚举来实现单例模式。不仅能避免多线程同步问题,而且还能防止反序列化重新创建
新的对象。
2) 这种方式是 Effective Java 作者 Josh Bloch 提倡的方式
3) 结论:推荐使用

```

单例使用场景和一些例子

1. 我们 JDK 中,java.lang.Runtime 就是经典的单例模式(饿汉式)  
1. 单例模式保证了 系统内存中该类只存在一个对象,节省了系统资源,对于一些需要频繁创建销毁的对象,使用单例模式可以提高系统性能  
2. 当想实例化一个单例类的时候,必须要记住使用相应的获取对象的方法,而不是使用 new  
3. 单例模式使用的场景:需要频繁的进行创建和销毁的对象、创建对象时耗时过多或耗费资源过多(即:重量级对象),但又经常用到的对象、工具类对象、频繁访问数据库或文件的对象(比如数据源、session 工厂等)  
单例模式的详解  
[深入理解单例模式](https://www.cnblogs.com/wuzaipei/p/10974561.html) 



<A name="cxg"> 工厂模式 </A> 

#### 一、一句话概括工厂模式

    简单工厂：一个工厂类，一个产品抽象类。
    工厂方法：多个工厂类，一个产品抽象类。
    抽象工厂：多个工厂类，多个产品抽象类。

#### 二、生活中的工厂模式

    简单工厂类：一个麦当劳店，可以生产多种汉堡。
    工厂方法类：一个麦当劳店，可以生产多种汉堡。一个肯德基店，也可以生产多种汉堡。
    抽象工厂类：百胜餐饮集团下有肯德基和百事公司，肯德基生产汉堡，百事公司生成百事可乐

简单工厂模式 它提供了一种创建对象的最佳方式。在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。
#### 简单工厂模式的优缺点
优点在于实现对象的创建和对象的使用分离，将对象的创建交给专门的工厂类负责，但是其最大的缺点在于工厂类不够灵活
缺点在于工厂类不够灵活，增加新的具体产品需要修改工厂类的判断逻辑代码，而且产品较多时，工厂方法代码逻辑将会非常复杂。

一个简单的示例
第一步创建接口
```java

Shape.java
public interface Shape {
   void draw();
}

```

第二步创建接口的实现类
```java

Rectangle.java
public class Rectangle implements Shape {
 
   @Override
   public void draw() {
      System.out.println("Inside Rectangle::draw() method.");
   }
}

Square.java
public class Square implements Shape {
 
   @Override
   public void draw() {
      System.out.println("Inside Square::draw() method.");
   }
}


Circle.java
public class Circle implements Shape {

   @Override
   public void draw() {
      System.out.println("Inside Circle::draw() method.");
   }
}

```
第三步创建工厂生成给定的实体类对象
```

ShapeFactory.java
public class ShapeFactory {
    
   //使用 getShape 方法获取形状类型的对象
   public Shape getShape(String shapeType){
      if(shapeType == null){
         return null;
      }        
      if(shapeType.equalsIgnoreCase("CIRCLE")){
         return new Circle();
      } else if(shapeType.equalsIgnoreCase("RECTANGLE")){
         return new Rectangle();
      } else if(shapeType.equalsIgnoreCase("SQUARE")){
         return new Square();
      }
      return null;
   }
}

```

第四步 获取实体类对象使用对象
```

FactoryPatternDemo.java
public class FactoryPatternDemo {
 
   public static void main(String[] args) {
      ShapeFactory shapeFactory = new ShapeFactory();
 
      //获取 Circle 的对象，并调用它的 draw 方法
      Shape shape1 = shapeFactory.getShape("CIRCLE");
 
      //调用 Circle 的 draw 方法
      shape1.draw();
 
      //获取 Rectangle 的对象，并调用它的 draw 方法
      Shape shape2 = shapeFactory.getShape("RECTANGLE");
 
      //调用 Rectangle 的 draw 方法
      shape2.draw();
 
      //获取 Square 的对象，并调用它的 draw 方法
      Shape shape3 = shapeFactory.getShape("SQUARE");
 
      //调用 Square 的 draw 方法
      shape3.draw();
   }
}

```

工厂方法就是
不在只是创建一个统一的工厂了 而是将工厂接口 然后根据不同的产品创建不同的工厂来进行具体类的创建

修改方面的案例就是
```java
public interface FactoryShape
{
public Shape manushape{}
}
```
```
public SquareFactory implements FactoryShape
{
	@Override
	public Shape manushape{
	return new Square();
	}
}
```

```
public CircleFactory implements FactoryShape
{
	@Override
	public Shape manushape{
	return new Cricle();
	}
}
```

```
public class test {
    public static void main(String[] args) {
        CircleFactory cFactory = new CircleFactory();
        //获取 Circle 的对象，并调用它的 draw 方法
        Shape shape1 = cFactory.manushape();
        //调用 Circle 的 draw 方法
        shape1.draw();

		SquareFcatory sFactory = new SquareFactory();
        //获取 Rectangle 的对象，并调用它的 draw 方法
        Shape shape2 = sFactro.manyshape();
        //调用 Rectangle 的 draw 方法
        shape2.draw();
    }
}
```
### 工厂方法的优缺点
优点
+ 更符合开-闭原则 新增一种产品时，只需要增加相应的具体产品类和相应的工厂子类即可
简单工厂模式需要修改工厂类的判断逻辑

+ 符合单一职责原则 
每个具体工厂类只负责创建对应的产品
简单工厂中的工厂类存在复杂的switch逻辑判断

###  缺点

  +  添加新产品时，除了增加新产品类外，还要提供与之对应的具体工厂类，系统类的个数将成对增加，在一定程度上增加了系统的复杂度；同时，有更多的类需要编译和运行，会给系统带来一些额外的开销；
  +  由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。
  +  虽然保证了工厂方法内的对修改关闭，但对于使用工厂方法的类，如果要更换另外一种产品，仍然需要修改实例化的具体工厂类；
  +  一个具体工厂只能创建一种具体产品

  最后还有一个问题就是这个网址下的笔记关于对简单工厂方法的讨论了
  甲方的观点是可以使用反射机制来解决没吃增加一个产品就要增加一个对象的事项工厂
  ```
  public class ShapeFactory {
    public static Object getClass(Class<?extends Shape> clazz) {
        Object obj = null;

        try {
            obj = Class.forName(clazz.getName()).newInstance();
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } catch (InstantiationException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        }

        return obj;
    }
}
  ```
使用的时候就是采用
```
Rectangle rect = (Rectangle) ShapeFactory.getClass(Rectangle.class);
rect.draw();
Square square = (Square) ShapeFactory.getClass(Square.class);
square.draw();
```

乙方的观点
其实使用反射是一种不错的办法，但反射也是从类名反射而不能从类反射！

先看一下工厂模式是用来干什么的——属于创建模式，解决子类创建问题的。换句话来说，调用者并不知道运行时真正的类名，只知道从“Circle"可以创建出一个shape接口的类，至于类的名称是否叫'Circle"，调用者并不知情。所以真正的对工厂进行扩展的方式（防止程序员调用出错）可以考虑使用一个枚举类（防止传入参数时，把circle拼写错误）。

如果调用者参肯定类型是Circle的话，那么其工厂没有存在的意义了！

比如 IShape shape = new Circle();这样不是更好？也就是说调用者有了Circle这个知识是可以直接调用的，根据DP（迪米特法则）其实调用者并不知道有一个Circle类的存在，他只需要知道这个IShape接口可以计算圆面积，而不需要知道；圆这个类到底是什么类名——他只知道给定一个”circle"字符串的参数,IShape接口可以自动计算圆的面积就可以了！

其实在.net类库中存在这个模式的的一个典型的。但他引入的另一个概念“可插入编程协议”。

那个就是
```
WebRequest req = WebRequest.Create("http://ccc......");
```
可以自动创建一个HttpWebRequest的对象，当然，如果你给定的是一个ftp地址，他会自动创建一个FtpWebRequest对象。工厂模式中着重介绍的是这种通过某个特定的参数，让你一个接口去干对应不同的事而已！而不是调用者知道了类！

比如如果圆的那个类名叫"CircleShape“呢？不管是反射还是泛型都干扰了你们具体类的生成！其实这个要说明的问题就是这个，调用者（clinet)只知道IShape的存在，在创建时给IShape一个参数"Circle",它可以计算圆的面积之类的工作，但是为什么会执行这些工作，根据迪米特法则，client是不用知道的。

我想问一下那些写笔记的哥们，如果你们知道了泛型，那么为什么不直接使用呢？干吗还需要经过工厂这个类呢？不觉得多余了吗？

如果，我只是说如果，如果所有从IShape继承的类都是Internal类型的呢？而client肯定不会与IShape一个空间！这时，你会了现你根本无法拿到这个类名！

Create时使用注册机制是一种简单的办法，比如使用一个枚举类，把功能总结到一处。而反射也是一种最简单的办法，调用者输入的名称恰是类名称或某种规则时使用，比如调用者输入的是Circle，而类恰是CircleShape，那么可以通过输入+”Shape"字符串形成新的类名，然后从字符串将运行类反射出来！

工厂的创建行为，就这些作用，还被你们用反射或泛型转嫁给了调用者（clinet)，那么，这种情况下，要工厂类何用？！

**没看明白** ............................................................................................................

最后就是抽象工厂模式了  简单的来说就是为我们前面的方法工厂里面的多个工厂 在创建一个工厂 用来创建方法工厂里面的工厂大致意思也就是这样了   

[抽象工厂模式详解](https://www.runoob.com/design-pattern/abstract-factory-pattern.html) 

  
<A name="yxm"> 原型模式 </A>  

原型模式其实实现的是**用原型实例指定创建对象的种类,并且通过拷贝这些原型,创建新的对象**

解决的方法 就是 要被克隆的类 实现 Cloneable接口 重写它的clone()方法

```java
class Jiao{
    int i;
    public int getI() {
        return i;
    }

    public void setI(int i) {
        this.i = i;
    }
    Jiao(int i)
    {
        this.i=i;
    }

}
public class Sheep implements Cloneable{
    private String name;
    private int age;
    public Jiao jiao;
    private String color;
    private String address = "蒙古羊";
    public Sheep friend; //是对象, 克隆是会如何处理, 默认是浅拷贝
    public Sheep(String name, int age, String color,Jiao jiao) {
        super();
        this.name = name;
        this.age = age;
        this.color = color;
        this.jiao = jiao;

    }
    @Override
    public String toString() {
        return "jiao="+jiao.getI()+"Sheep [name=" + name + ", age=" + age + ", color=" + color + ", address=" + address + "]";
    }
    //克隆该实例,使用默认的 clone 方法来完成
    @Override
    protected Object clone()
    {

        Sheep sheep = null;
        try {
            sheep = (Sheep)super.clone();
        } catch (Exception e) {
// TODO: handle exception
            System.out.println(e.getMessage());
        }
        // TODO Auto-generated method stub
        return sheep;
    }

}
	
```

对它进行测试
```

public class test {
    public static void main(String[] args) {
        System.out.println("原型模式完成对象的创建");
// TODO Auto-generated method stub
        Jiao jiao = new Jiao(1);
        Sheep sheep = new Sheep("tom", 1, "白色",jiao);
        sheep.friend = new Sheep("jack", 2, "黑色",jiao);
        Sheep sheep2 = (Sheep)sheep.clone(); //克隆
        Sheep sheep3 = (Sheep)sheep.clone(); //克隆
        Sheep sheep5 = (Sheep)sheep.clone(); //克隆
        sheep5.jiao.setI(2);


        System.out.println("sheep2 =" + sheep2 + "sheep2.friend=" + sheep2.friend.hashCode());
        System.out.println("sheep3 =" + sheep3 + "sheep3.friend=" + sheep3.friend.hashCode());
        System.out.println("sheep5 =" + sheep5 + "sheep5.friend=" + sheep5.friend.hashCode());
    }
}
```

打印结果
```
原型模式完成对象的创建
sheep2 =jiao=2Sheep [name=tom, age=1, color=白色, address=蒙古羊]sheep2.friend=1956725890
sheep3 =jiao=2Sheep [name=tom, age=1, color=白色, address=蒙古羊]sheep3.friend=1956725890
sheep5 =jiao=2Sheep [name=tom, age=1, color=白色, address=蒙古羊]sheep5.friend=1956725890
```

有打印结果可以知道  我们默认实现的是浅拷贝  也就是说 在类的属性中的引用类型其实是给的一个地址 并没有为引用类型创建一个新的对象

还存在一个重要的问题就是  向对象中修改一个的值 大家都会变化 也就是上面代码演示的  
### 深拷贝问题

深拷贝基本介绍
1) 复制对象的所有基本数据类型的成员变量值
2) 为所有引用数据类型的成员变量申请存储空间,并复制每个引用数据类型成员变量所引用的对象,直到该对象
可达的所有对象。也就是说,对象进行深拷贝要对整个对象(包括对象的引用类型)进行拷贝
3) 深拷贝实现方式 1:重写 clone 方法来实现深拷贝
4) 深拷贝实现方式 2:通过对象序列化实现深拷贝(推荐)

两种方法  
第一种还是实现cloneable中 进行  

```
    protected Object clone()
    {

        Sheep sheep = null;
        try {
            sheep = (Sheep)super.clone();
        } catch (Exception e) {
// TODO: handle exception
            System.out.println(e.getMessage());
        }
        // TODO Auto-generated method stub
        sheep.jiao = (Jiao) jiao.clone();
        return sheep;
    }
```
当然这里还要注意在 这个的基础上就是  我们要吧Jiao这个类也要改变才可以 也就是它要是想要实现复制就是也要实现 cloneable接口才可以 也就是会如下的内容了
```
class Jiao implements Cloneable{
    int i;
    public int getI() {
        return i;
    }

    public void setI(int i) {
        this.i = i;
    }
    Jiao(int i)
    {
        this.i=i;
    }
    public Jiao clone()
    {
        Jiao jiao = null;
        try {
            jiao = (Jiao) super.clone();
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }
        return jiao;
        
    }
}
```

这样结果就和之前不一样了
```
原型模式完成对象的创建
sheep2 =jiao=1Sheep [name=tom, age=1, color=白色, address=蒙古羊]sheep2.friend=1956725890
sheep3 =jiao=1Sheep [name=tom, age=1, color=白色, address=蒙古羊]sheep3.friend=1956725890
sheep5 =jiao=2Sheep [name=tom, age=1, color=白色, address=蒙古羊]sheep5.friend=1956725890
```



这样就可以了


第二种方法 
```
public class test {


    public static void main(String[] args) {
        System.out.println("原型模式完成对象的创建");
// TODO Auto-generated method stub
        Jiao jiao = new Jiao(1);
        Sheep sheep = new Sheep("tom", 1, "白色",jiao);
        sheep.friend = new Sheep("jack", 2, "黑色",jiao);
//下面是深度克隆改变的地方
        Sheep sheep2 = CloneUtils.clone(sheep); //克隆
        Sheep sheep3 =  CloneUtils.clone(sheep); //克隆
        Sheep sheep5 = CloneUtils.clone(sheep); //克隆
        sheep5.jiao.setI(2);


        System.out.println("sheep2 =" + sheep2 + "sheep2.friend=" + sheep2.friend.hashCode());
        System.out.println("sheep3 =" + sheep3 + "sheep3.friend=" + sheep3.friend.hashCode());
        System.out.println("sheep5 =" + sheep5 + "sheep5.friend=" + sheep5.friend.hashCode());
    }
}
```

一个生成字节流的方法一个类
```
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;

/**
 * 通过字节流序列化实现深拷贝，需要深拷贝的对象必须实现Serializable接口
 *
 * @author Administrator
 */
public class CloneUtils {
    @SuppressWarnings("unchecked")
    public static <T extends Serializable> T clone(T obj){
        T cloneObj = null;
        try {
            //写入字节流
            ByteArrayOutputStream out = new ByteArrayOutputStream();
            ObjectOutputStream obs = new ObjectOutputStream(out);
            obs.writeObject(obj);
            obs.close();

            //分配内存，写入原始对象，生成新对象
            ByteArrayInputStream ios = new ByteArrayInputStream(out.toByteArray());
            ObjectInputStream ois = new ObjectInputStream(ios);
            //返回生成的新对象
            cloneObj = (T) ois.readObject();
            ois.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return cloneObj;
    }
}
```


下面要被拷贝的方法都要加上 实现Serializable这个接口
```
import java.io.Serializable;

class Jiao implements Cloneable, Serializable {
    int i;
    public int getI() {
        return i;
    }

    public void setI(int i) {
        this.i = i;
    }
    Jiao(int i)
    {
        this.i=i;
    }
    public Jiao clone()
    {
        Jiao jiao = null;
        try {
            jiao = (Jiao) super.clone();
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }
        return jiao;

    }
}
```

```
import java.io.Serializable;

public class Sheep implements Cloneable , Serializable {
    private String name;
    private int age;
    public Jiao jiao;
    private String color;
    private String address = "蒙古羊";
    public Sheep friend; //是对象, 克隆是会如何处理, 默认是浅拷贝
    public Sheep(String name, int age, String color,Jiao jiao) {
        super();
        this.name = name;
        this.age = age;
        this.color = color;
        this.jiao = jiao;

    }
    @Override
    public String toString() {
        return "jiao="+jiao.getI()+"Sheep [name=" + name + ", age=" + age + ", color=" + color + ", address=" + address + "]";
    }
    //克隆该实例,使用默认的 clone 方法来完成
    @Override
    protected Object clone()
    {

        Sheep sheep = null;
        try {
            sheep = (Sheep)super.clone();
        } catch (Exception e) {
// TODO: handle exception
            System.out.println(e.getMessage());
        }
        // TODO Auto-generated method stub
        sheep.jiao = (Jiao) jiao.clone();
        return sheep;
    }

}
```
最后总结一下 
1. 创建新的对象比较复杂时,可以利用原型模式简化对象的创建过程,同时也能够提高效率
2. 不用重新初始化对象,而是动态地获得对象运行时的状态
3. 如果原始对象发生变化(增加或者减少属性),其它克隆对象的也会发生相应的变化,无需修改代码
4. 在实现深克隆的时候可能需要比较复杂的代码
5. 缺点:需要为每一个类配备一个克隆方法,这对全新的类来说不是很难,但对已有的类进行改造时,需要修改 其源代码,违背了 ocp 原则,这点请同学们注意.



<A name="jzz"> 建造者模式 </A>  

创建这模式中要弄清楚四个角色就可以了  
1. Product(产品角色): 一个具体的产品对象。
2. Builder(抽象建造者): 创建一个 Product 对象的各个部件指定的 接口/抽象类。
3. ConcreteBuilder(具体建造者): 实现接口,构建和装配各个部件。
4. Director(指挥者): 构建一个使用 Builder 接口的对象。它主要是用于创建一个复杂的对象。它主要有两个作 用,一是:隔离了客户与对象的生产过程,二是:负责控制产品对象的生产过程。
![建造者模式UML图](https://github.com/shenxixi250/photo/blob/master/shejimoshi_photo/l.png) 
![实例](https://github.com/shenxixi250/photo/blob/master/shejimoshi_photo/lk.png) 
